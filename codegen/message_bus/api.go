// Package message_bus provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package message_bus

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Access_tokenScopes = "access_token.Scopes"
)

// Action defines model for Action.
type Action struct {
	// Name action name
	Name string `json:"name"`

	// Properties event properties
	Properties map[string]string `json:"properties"`

	// SourceID associated source id
	SourceID string `json:"sourceID"`

	// Timestamp timestamp this action took place
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ActionType defines model for ActionType.
type ActionType struct {
	// Name action name
	//
	// (there is no naming convention for action names, but it is recommended to name each as structural and descriptive as possible)
	Name             string         `json:"name"`
	PropertyTypeList []PropertyType `json:"propertyTypeList"`

	// SourceID action source id to identify where the action will take
	SourceID string `json:"sourceID"`
}

// BaseResponse defines model for BaseResponse.
type BaseResponse struct {
	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// Event defines model for Event.
type Event struct {
	// Name event name
	Name string `json:"name"`

	// Properties event properties
	Properties map[string]string `json:"properties"`

	// SourceID associated source id
	SourceID string `json:"sourceID"`

	// Timestamp timestamp this event took place
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Uuid event uuid
	Uuid *string `json:"uuid,omitempty"`
}

// EventType defines model for EventType.
type EventType struct {
	// Name event name
	//
	// (there is no naming convention for event names, but it is recommended to name each as structural and descriptive as possible)
	Name             string         `json:"name"`
	PropertyTypeList []PropertyType `json:"propertyTypeList"`

	// SourceID event source id to identify where the event comes from
	SourceID string `json:"sourceID"`
}

// PropertyType defines model for PropertyType.
type PropertyType struct {
	Description *string `json:"description,omitempty"`
	Example     *string `json:"example,omitempty"`

	// Name property name
	//
	// > It is recommended for a property name to be as descriptive as possible. One option is to prefix with a namespace.
	// > - If the property is source specific, prefix with source ID. For example, `local-storage:vendor`
	// > - Otherwise, prefix with `common:`. For example, `common:email`
	// >
	// > Some bad examples are `id`, `avail`, `blk`...which can be ambiguous and confusing.
	Name string `json:"name"`
}

// ActionName defines model for ActionName.
type ActionName = string

// ActionNames defines model for ActionNames.
type ActionNames = []string

// EventName defines model for EventName.
type EventName = string

// EventNames defines model for EventNames.
type EventNames = []string

// SourceID defines model for SourceID.
type SourceID = string

// GetActionTypeOK defines model for GetActionTypeOK.
type GetActionTypeOK = ActionType

// GetActionTypesOK defines model for GetActionTypesOK.
type GetActionTypesOK = []ActionType

// GetEventTypeOK defines model for GetEventTypeOK.
type GetEventTypeOK = EventType

// GetEventTypesOK defines model for GetEventTypesOK.
type GetEventTypesOK = []EventType

// PublishEventOK defines model for PublishEventOK.
type PublishEventOK = Event

// ResponseBadRequest defines model for ResponseBadRequest.
type ResponseBadRequest = BaseResponse

// ResponseConflict defines model for ResponseConflict.
type ResponseConflict = BaseResponse

// ResponseInternalServerError defines model for ResponseInternalServerError.
type ResponseInternalServerError = BaseResponse

// ResponseNotFound defines model for ResponseNotFound.
type ResponseNotFound = BaseResponse

// ResponseOK defines model for ResponseOK.
type ResponseOK = BaseResponse

// TriggerActionOK defines model for TriggerActionOK.
type TriggerActionOK = Action

// PublishEvent event properties
type PublishEvent map[string]string

// RegisterActionTypes defines model for RegisterActionTypes.
type RegisterActionTypes = []ActionType

// RegisterEventTypes defines model for RegisterEventTypes.
type RegisterEventTypes = []EventType

// TriggerAction action properties
type TriggerAction map[string]string

// SubscribeActionWSParams defines parameters for SubscribeActionWS.
type SubscribeActionWSParams struct {
	Names *ActionNames `form:"names,omitempty" json:"names,omitempty"`
}

// TriggerActionJSONBody defines parameters for TriggerAction.
type TriggerActionJSONBody map[string]string

// RegisterActionTypesJSONBody defines parameters for RegisterActionTypes.
type RegisterActionTypesJSONBody = []ActionType

// SubscribeEventWSParams defines parameters for SubscribeEventWS.
type SubscribeEventWSParams struct {
	Names *EventNames `form:"names,omitempty" json:"names,omitempty"`
}

// PublishEventJSONBody defines parameters for PublishEvent.
type PublishEventJSONBody map[string]string

// RegisterEventTypesJSONBody defines parameters for RegisterEventTypes.
type RegisterEventTypesJSONBody = []EventType

// TriggerActionJSONRequestBody defines body for TriggerAction for application/json ContentType.
type TriggerActionJSONRequestBody TriggerActionJSONBody

// RegisterActionTypesJSONRequestBody defines body for RegisterActionTypes for application/json ContentType.
type RegisterActionTypesJSONRequestBody = RegisterActionTypesJSONBody

// PublishEventJSONRequestBody defines body for PublishEvent for application/json ContentType.
type PublishEventJSONRequestBody PublishEventJSONBody

// RegisterEventTypesJSONRequestBody defines body for RegisterEventTypes for application/json ContentType.
type RegisterEventTypesJSONRequestBody = RegisterEventTypesJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubscribeActionWS request
	SubscribeActionWS(ctx context.Context, sourceId SourceID, params *SubscribeActionWSParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerAction request with any body
	TriggerActionWithBody(ctx context.Context, sourceId SourceID, name ActionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerAction(ctx context.Context, sourceId SourceID, name ActionName, body TriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionTypes request
	GetActionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterActionTypes request with any body
	RegisterActionTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterActionTypes(ctx context.Context, body RegisterActionTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionTypesBySourceID request
	GetActionTypesBySourceID(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionType request
	GetActionType(ctx context.Context, sourceId SourceID, name ActionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeEventWS request
	SubscribeEventWS(ctx context.Context, sourceId SourceID, params *SubscribeEventWSParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishEvent request with any body
	PublishEventWithBody(ctx context.Context, sourceId SourceID, name EventName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishEvent(ctx context.Context, sourceId SourceID, name EventName, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventTypes request
	GetEventTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterEventTypes request with any body
	RegisterEventTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterEventTypes(ctx context.Context, body RegisterEventTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventTypesBySourceID request
	GetEventTypesBySourceID(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventType request
	GetEventType(ctx context.Context, sourceId SourceID, name EventName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeSIO request
	SubscribeSIO(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollSIO request
	PollSIO(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscribeSIO2 request
	SubscribeSIO2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollSIO2 request
	PollSIO2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SubscribeActionWS(ctx context.Context, sourceId SourceID, params *SubscribeActionWSParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeActionWSRequest(c.Server, sourceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerActionWithBody(ctx context.Context, sourceId SourceID, name ActionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerActionRequestWithBody(c.Server, sourceId, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerAction(ctx context.Context, sourceId SourceID, name ActionName, body TriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerActionRequest(c.Server, sourceId, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterActionTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterActionTypesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterActionTypes(ctx context.Context, body RegisterActionTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterActionTypesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionTypesBySourceID(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionTypesBySourceIDRequest(c.Server, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionType(ctx context.Context, sourceId SourceID, name ActionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionTypeRequest(c.Server, sourceId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeEventWS(ctx context.Context, sourceId SourceID, params *SubscribeEventWSParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeEventWSRequest(c.Server, sourceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishEventWithBody(ctx context.Context, sourceId SourceID, name EventName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishEventRequestWithBody(c.Server, sourceId, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishEvent(ctx context.Context, sourceId SourceID, name EventName, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishEventRequest(c.Server, sourceId, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEventTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEventTypesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEventTypes(ctx context.Context, body RegisterEventTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEventTypesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventTypesBySourceID(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventTypesBySourceIDRequest(c.Server, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventType(ctx context.Context, sourceId SourceID, name EventName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventTypeRequest(c.Server, sourceId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeSIO(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeSIORequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollSIO(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollSIORequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscribeSIO2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeSIO2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollSIO2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollSIO2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSubscribeActionWSRequest generates requests for SubscribeActionWS
func NewSubscribeActionWSRequest(server string, sourceId SourceID, params *SubscribeActionWSParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Names != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerActionRequest calls the generic TriggerAction builder with application/json body
func NewTriggerActionRequest(server string, sourceId SourceID, name ActionName, body TriggerActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerActionRequestWithBody(server, sourceId, name, "application/json", bodyReader)
}

// NewTriggerActionRequestWithBody generates requests for TriggerAction with any type of body
func NewTriggerActionRequestWithBody(server string, sourceId SourceID, name ActionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActionTypesRequest generates requests for GetActionTypes
func NewGetActionTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action_type")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterActionTypesRequest calls the generic RegisterActionTypes builder with application/json body
func NewRegisterActionTypesRequest(server string, body RegisterActionTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterActionTypesRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterActionTypesRequestWithBody generates requests for RegisterActionTypes with any type of body
func NewRegisterActionTypesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action_type")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActionTypesBySourceIDRequest generates requests for GetActionTypesBySourceID
func NewGetActionTypesBySourceIDRequest(server string, sourceId SourceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action_type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionTypeRequest generates requests for GetActionType
func NewGetActionTypeRequest(server string, sourceId SourceID, name ActionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/action_type/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeEventWSRequest generates requests for SubscribeEventWS
func NewSubscribeEventWSRequest(server string, sourceId SourceID, params *SubscribeEventWSParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Names != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishEventRequest calls the generic PublishEvent builder with application/json body
func NewPublishEventRequest(server string, sourceId SourceID, name EventName, body PublishEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishEventRequestWithBody(server, sourceId, name, "application/json", bodyReader)
}

// NewPublishEventRequestWithBody generates requests for PublishEvent with any type of body
func NewPublishEventRequestWithBody(server string, sourceId SourceID, name EventName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventTypesRequest generates requests for GetEventTypes
func NewGetEventTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event_type")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterEventTypesRequest calls the generic RegisterEventTypes builder with application/json body
func NewRegisterEventTypesRequest(server string, body RegisterEventTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterEventTypesRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterEventTypesRequestWithBody generates requests for RegisterEventTypes with any type of body
func NewRegisterEventTypesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event_type")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventTypesBySourceIDRequest generates requests for GetEventTypesBySourceID
func NewGetEventTypesBySourceIDRequest(server string, sourceId SourceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event_type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventTypeRequest generates requests for GetEventType
func NewGetEventTypeRequest(server string, sourceId SourceID, name EventName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "source_id", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/event_type/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeSIORequest generates requests for SubscribeSIO
func NewSubscribeSIORequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socket.io")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPollSIORequest generates requests for PollSIO
func NewPollSIORequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socket.io")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscribeSIO2Request generates requests for SubscribeSIO2
func NewSubscribeSIO2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socket.io/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPollSIO2Request generates requests for PollSIO2
func NewPollSIO2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socket.io/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubscribeActionWS request
	SubscribeActionWSWithResponse(ctx context.Context, sourceId SourceID, params *SubscribeActionWSParams, reqEditors ...RequestEditorFn) (*SubscribeActionWSResponse, error)

	// TriggerAction request with any body
	TriggerActionWithBodyWithResponse(ctx context.Context, sourceId SourceID, name ActionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerActionResponse, error)

	TriggerActionWithResponse(ctx context.Context, sourceId SourceID, name ActionName, body TriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerActionResponse, error)

	// GetActionTypes request
	GetActionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActionTypesResponse, error)

	// RegisterActionTypes request with any body
	RegisterActionTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterActionTypesResponse, error)

	RegisterActionTypesWithResponse(ctx context.Context, body RegisterActionTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterActionTypesResponse, error)

	// GetActionTypesBySourceID request
	GetActionTypesBySourceIDWithResponse(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*GetActionTypesBySourceIDResponse, error)

	// GetActionType request
	GetActionTypeWithResponse(ctx context.Context, sourceId SourceID, name ActionName, reqEditors ...RequestEditorFn) (*GetActionTypeResponse, error)

	// SubscribeEventWS request
	SubscribeEventWSWithResponse(ctx context.Context, sourceId SourceID, params *SubscribeEventWSParams, reqEditors ...RequestEditorFn) (*SubscribeEventWSResponse, error)

	// PublishEvent request with any body
	PublishEventWithBodyWithResponse(ctx context.Context, sourceId SourceID, name EventName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishEventResponse, error)

	PublishEventWithResponse(ctx context.Context, sourceId SourceID, name EventName, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishEventResponse, error)

	// GetEventTypes request
	GetEventTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventTypesResponse, error)

	// RegisterEventTypes request with any body
	RegisterEventTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEventTypesResponse, error)

	RegisterEventTypesWithResponse(ctx context.Context, body RegisterEventTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEventTypesResponse, error)

	// GetEventTypesBySourceID request
	GetEventTypesBySourceIDWithResponse(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*GetEventTypesBySourceIDResponse, error)

	// GetEventType request
	GetEventTypeWithResponse(ctx context.Context, sourceId SourceID, name EventName, reqEditors ...RequestEditorFn) (*GetEventTypeResponse, error)

	// SubscribeSIO request
	SubscribeSIOWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeSIOResponse, error)

	// PollSIO request
	PollSIOWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PollSIOResponse, error)

	// SubscribeSIO2 request
	SubscribeSIO2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeSIO2Response, error)

	// PollSIO2 request
	PollSIO2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PollSIO2Response, error)
}

type SubscribeActionWSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeActionWSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeActionWSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Action
	JSON400      *BaseResponse
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r TriggerActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionType
}

// Status returns HTTPResponse.Status
func (r GetActionTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterActionTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseResponse
	JSON400      *BaseResponse
	JSON409      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r RegisterActionTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterActionTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionTypesBySourceIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionType
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r GetActionTypesBySourceIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionTypesBySourceIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionType
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r GetActionTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeEventWSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeEventWSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeEventWSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON400      *BaseResponse
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r PublishEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EventType
	JSON500      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r GetEventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterEventTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseResponse
	JSON400      *BaseResponse
	JSON409      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r RegisterEventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterEventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventTypesBySourceIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EventType
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r GetEventTypesBySourceIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventTypesBySourceIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventType
	JSON404      *BaseResponse
}

// Status returns HTTPResponse.Status
func (r GetEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeSIOResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeSIOResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeSIOResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollSIOResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PollSIOResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollSIOResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscribeSIO2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubscribeSIO2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeSIO2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollSIO2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PollSIO2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollSIO2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubscribeActionWSWithResponse request returning *SubscribeActionWSResponse
func (c *ClientWithResponses) SubscribeActionWSWithResponse(ctx context.Context, sourceId SourceID, params *SubscribeActionWSParams, reqEditors ...RequestEditorFn) (*SubscribeActionWSResponse, error) {
	rsp, err := c.SubscribeActionWS(ctx, sourceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeActionWSResponse(rsp)
}

// TriggerActionWithBodyWithResponse request with arbitrary body returning *TriggerActionResponse
func (c *ClientWithResponses) TriggerActionWithBodyWithResponse(ctx context.Context, sourceId SourceID, name ActionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerActionResponse, error) {
	rsp, err := c.TriggerActionWithBody(ctx, sourceId, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerActionResponse(rsp)
}

func (c *ClientWithResponses) TriggerActionWithResponse(ctx context.Context, sourceId SourceID, name ActionName, body TriggerActionJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerActionResponse, error) {
	rsp, err := c.TriggerAction(ctx, sourceId, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerActionResponse(rsp)
}

// GetActionTypesWithResponse request returning *GetActionTypesResponse
func (c *ClientWithResponses) GetActionTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActionTypesResponse, error) {
	rsp, err := c.GetActionTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionTypesResponse(rsp)
}

// RegisterActionTypesWithBodyWithResponse request with arbitrary body returning *RegisterActionTypesResponse
func (c *ClientWithResponses) RegisterActionTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterActionTypesResponse, error) {
	rsp, err := c.RegisterActionTypesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterActionTypesResponse(rsp)
}

func (c *ClientWithResponses) RegisterActionTypesWithResponse(ctx context.Context, body RegisterActionTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterActionTypesResponse, error) {
	rsp, err := c.RegisterActionTypes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterActionTypesResponse(rsp)
}

// GetActionTypesBySourceIDWithResponse request returning *GetActionTypesBySourceIDResponse
func (c *ClientWithResponses) GetActionTypesBySourceIDWithResponse(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*GetActionTypesBySourceIDResponse, error) {
	rsp, err := c.GetActionTypesBySourceID(ctx, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionTypesBySourceIDResponse(rsp)
}

// GetActionTypeWithResponse request returning *GetActionTypeResponse
func (c *ClientWithResponses) GetActionTypeWithResponse(ctx context.Context, sourceId SourceID, name ActionName, reqEditors ...RequestEditorFn) (*GetActionTypeResponse, error) {
	rsp, err := c.GetActionType(ctx, sourceId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionTypeResponse(rsp)
}

// SubscribeEventWSWithResponse request returning *SubscribeEventWSResponse
func (c *ClientWithResponses) SubscribeEventWSWithResponse(ctx context.Context, sourceId SourceID, params *SubscribeEventWSParams, reqEditors ...RequestEditorFn) (*SubscribeEventWSResponse, error) {
	rsp, err := c.SubscribeEventWS(ctx, sourceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeEventWSResponse(rsp)
}

// PublishEventWithBodyWithResponse request with arbitrary body returning *PublishEventResponse
func (c *ClientWithResponses) PublishEventWithBodyWithResponse(ctx context.Context, sourceId SourceID, name EventName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishEventResponse, error) {
	rsp, err := c.PublishEventWithBody(ctx, sourceId, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishEventResponse(rsp)
}

func (c *ClientWithResponses) PublishEventWithResponse(ctx context.Context, sourceId SourceID, name EventName, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishEventResponse, error) {
	rsp, err := c.PublishEvent(ctx, sourceId, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishEventResponse(rsp)
}

// GetEventTypesWithResponse request returning *GetEventTypesResponse
func (c *ClientWithResponses) GetEventTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventTypesResponse, error) {
	rsp, err := c.GetEventTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventTypesResponse(rsp)
}

// RegisterEventTypesWithBodyWithResponse request with arbitrary body returning *RegisterEventTypesResponse
func (c *ClientWithResponses) RegisterEventTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEventTypesResponse, error) {
	rsp, err := c.RegisterEventTypesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEventTypesResponse(rsp)
}

func (c *ClientWithResponses) RegisterEventTypesWithResponse(ctx context.Context, body RegisterEventTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEventTypesResponse, error) {
	rsp, err := c.RegisterEventTypes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEventTypesResponse(rsp)
}

// GetEventTypesBySourceIDWithResponse request returning *GetEventTypesBySourceIDResponse
func (c *ClientWithResponses) GetEventTypesBySourceIDWithResponse(ctx context.Context, sourceId SourceID, reqEditors ...RequestEditorFn) (*GetEventTypesBySourceIDResponse, error) {
	rsp, err := c.GetEventTypesBySourceID(ctx, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventTypesBySourceIDResponse(rsp)
}

// GetEventTypeWithResponse request returning *GetEventTypeResponse
func (c *ClientWithResponses) GetEventTypeWithResponse(ctx context.Context, sourceId SourceID, name EventName, reqEditors ...RequestEditorFn) (*GetEventTypeResponse, error) {
	rsp, err := c.GetEventType(ctx, sourceId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventTypeResponse(rsp)
}

// SubscribeSIOWithResponse request returning *SubscribeSIOResponse
func (c *ClientWithResponses) SubscribeSIOWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeSIOResponse, error) {
	rsp, err := c.SubscribeSIO(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeSIOResponse(rsp)
}

// PollSIOWithResponse request returning *PollSIOResponse
func (c *ClientWithResponses) PollSIOWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PollSIOResponse, error) {
	rsp, err := c.PollSIO(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollSIOResponse(rsp)
}

// SubscribeSIO2WithResponse request returning *SubscribeSIO2Response
func (c *ClientWithResponses) SubscribeSIO2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeSIO2Response, error) {
	rsp, err := c.SubscribeSIO2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeSIO2Response(rsp)
}

// PollSIO2WithResponse request returning *PollSIO2Response
func (c *ClientWithResponses) PollSIO2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PollSIO2Response, error) {
	rsp, err := c.PollSIO2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollSIO2Response(rsp)
}

// ParseSubscribeActionWSResponse parses an HTTP response from a SubscribeActionWSWithResponse call
func ParseSubscribeActionWSResponse(rsp *http.Response) (*SubscribeActionWSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeActionWSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerActionResponse parses an HTTP response from a TriggerActionWithResponse call
func ParseTriggerActionResponse(rsp *http.Response) (*TriggerActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Action
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetActionTypesResponse parses an HTTP response from a GetActionTypesWithResponse call
func ParseGetActionTypesResponse(rsp *http.Response) (*GetActionTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterActionTypesResponse parses an HTTP response from a RegisterActionTypesWithResponse call
func ParseRegisterActionTypesResponse(rsp *http.Response) (*RegisterActionTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterActionTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetActionTypesBySourceIDResponse parses an HTTP response from a GetActionTypesBySourceIDWithResponse call
func ParseGetActionTypesBySourceIDResponse(rsp *http.Response) (*GetActionTypesBySourceIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionTypesBySourceIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetActionTypeResponse parses an HTTP response from a GetActionTypeWithResponse call
func ParseGetActionTypeResponse(rsp *http.Response) (*GetActionTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSubscribeEventWSResponse parses an HTTP response from a SubscribeEventWSWithResponse call
func ParseSubscribeEventWSResponse(rsp *http.Response) (*SubscribeEventWSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeEventWSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePublishEventResponse parses an HTTP response from a PublishEventWithResponse call
func ParsePublishEventResponse(rsp *http.Response) (*PublishEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetEventTypesResponse parses an HTTP response from a GetEventTypesWithResponse call
func ParseGetEventTypesResponse(rsp *http.Response) (*GetEventTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterEventTypesResponse parses an HTTP response from a RegisterEventTypesWithResponse call
func ParseRegisterEventTypesResponse(rsp *http.Response) (*RegisterEventTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterEventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetEventTypesBySourceIDResponse parses an HTTP response from a GetEventTypesBySourceIDWithResponse call
func ParseGetEventTypesBySourceIDResponse(rsp *http.Response) (*GetEventTypesBySourceIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventTypesBySourceIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetEventTypeResponse parses an HTTP response from a GetEventTypeWithResponse call
func ParseGetEventTypeResponse(rsp *http.Response) (*GetEventTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSubscribeSIOResponse parses an HTTP response from a SubscribeSIOWithResponse call
func ParseSubscribeSIOResponse(rsp *http.Response) (*SubscribeSIOResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeSIOResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePollSIOResponse parses an HTTP response from a PollSIOWithResponse call
func ParsePollSIOResponse(rsp *http.Response) (*PollSIOResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollSIOResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubscribeSIO2Response parses an HTTP response from a SubscribeSIO2WithResponse call
func ParseSubscribeSIO2Response(rsp *http.Response) (*SubscribeSIO2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeSIO2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePollSIO2Response parses an HTTP response from a PollSIO2WithResponse call
func ParsePollSIO2Response(rsp *http.Response) (*PollSIO2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollSIO2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Subscribe to actions by source ID (WebSocket)
	// (GET /action/{source_id})
	SubscribeActionWS(ctx echo.Context, sourceId SourceID, params SubscribeActionWSParams) error
	// Trigger an action
	// (POST /action/{source_id}/{name})
	TriggerAction(ctx echo.Context, sourceId SourceID, name ActionName) error
	// List action types
	// (GET /action_type)
	GetActionTypes(ctx echo.Context) error
	// Register one or more action types
	// (POST /action_type)
	RegisterActionTypes(ctx echo.Context) error
	// Get action types by source ID
	// (GET /action_type/{source_id})
	GetActionTypesBySourceID(ctx echo.Context, sourceId SourceID) error
	// Get an action type by source ID and name
	// (GET /action_type/{source_id}/{name})
	GetActionType(ctx echo.Context, sourceId SourceID, name ActionName) error
	// Subscribe to events by source ID (WebSocket)
	// (GET /event/{source_id})
	SubscribeEventWS(ctx echo.Context, sourceId SourceID, params SubscribeEventWSParams) error
	// Publish an event
	// (POST /event/{source_id}/{name})
	PublishEvent(ctx echo.Context, sourceId SourceID, name EventName) error
	// List event types
	// (GET /event_type)
	GetEventTypes(ctx echo.Context) error
	// Register one or more event types
	// (POST /event_type)
	RegisterEventTypes(ctx echo.Context) error
	// Get event types by source ID
	// (GET /event_type/{source_id})
	GetEventTypesBySourceID(ctx echo.Context, sourceId SourceID) error
	// Get an event type by source ID and name
	// (GET /event_type/{source_id}/{name})
	GetEventType(ctx echo.Context, sourceId SourceID, name EventName) error
	// Subscribe to events and actions (SocketIO)
	// (GET /socket.io)
	SubscribeSIO(ctx echo.Context) error
	// Poll events and actions (SocketIO)
	// (POST /socket.io)
	PollSIO(ctx echo.Context) error
	// Subscribe to events and actions (SocketIO)
	// (GET /socket.io/)
	SubscribeSIO2(ctx echo.Context) error
	// Poll events and actions (SocketIO)
	// (POST /socket.io/)
	PollSIO2(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SubscribeActionWS converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeActionWS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeActionWSParams
	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeActionWS(ctx, sourceId, params)
	return err
}

// TriggerAction converts echo context to params.
func (w *ServerInterfaceWrapper) TriggerAction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name ActionName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TriggerAction(ctx, sourceId, name)
	return err
}

// GetActionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionTypes(ctx)
	return err
}

// RegisterActionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterActionTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterActionTypes(ctx)
	return err
}

// GetActionTypesBySourceID converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionTypesBySourceID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionTypesBySourceID(ctx, sourceId)
	return err
}

// GetActionType converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name ActionName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionType(ctx, sourceId, name)
	return err
}

// SubscribeEventWS converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeEventWS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeEventWSParams
	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeEventWS(ctx, sourceId, params)
	return err
}

// PublishEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PublishEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name EventName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PublishEvent(ctx, sourceId, name)
	return err
}

// GetEventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventTypes(ctx)
	return err
}

// RegisterEventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterEventTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterEventTypes(ctx)
	return err
}

// GetEventTypesBySourceID converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventTypesBySourceID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventTypesBySourceID(ctx, sourceId)
	return err
}

// GetEventType converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name EventName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventType(ctx, sourceId, name)
	return err
}

// SubscribeSIO converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeSIO(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeSIO(ctx)
	return err
}

// PollSIO converts echo context to params.
func (w *ServerInterfaceWrapper) PollSIO(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PollSIO(ctx)
	return err
}

// SubscribeSIO2 converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeSIO2(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeSIO2(ctx)
	return err
}

// PollSIO2 converts echo context to params.
func (w *ServerInterfaceWrapper) PollSIO2(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PollSIO2(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/action/:source_id", wrapper.SubscribeActionWS)
	router.POST(baseURL+"/action/:source_id/:name", wrapper.TriggerAction)
	router.GET(baseURL+"/action_type", wrapper.GetActionTypes)
	router.POST(baseURL+"/action_type", wrapper.RegisterActionTypes)
	router.GET(baseURL+"/action_type/:source_id", wrapper.GetActionTypesBySourceID)
	router.GET(baseURL+"/action_type/:source_id/:name", wrapper.GetActionType)
	router.GET(baseURL+"/event/:source_id", wrapper.SubscribeEventWS)
	router.POST(baseURL+"/event/:source_id/:name", wrapper.PublishEvent)
	router.GET(baseURL+"/event_type", wrapper.GetEventTypes)
	router.POST(baseURL+"/event_type", wrapper.RegisterEventTypes)
	router.GET(baseURL+"/event_type/:source_id", wrapper.GetEventTypesBySourceID)
	router.GET(baseURL+"/event_type/:source_id/:name", wrapper.GetEventType)
	router.GET(baseURL+"/socket.io", wrapper.SubscribeSIO)
	router.POST(baseURL+"/socket.io", wrapper.PollSIO)
	router.GET(baseURL+"/socket.io/", wrapper.SubscribeSIO2)
	router.POST(baseURL+"/socket.io/", wrapper.PollSIO2)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbXW8bt9L+KwTf98IBVpLjuOe0AnoR121q9LQOogA5QGxY3N2RlvEuuSG5spVA//2A",
	"5H5wP2St5LUNFL1KJJEzw5lnZh5++DsOeJJyBkxJPP2OUyJIAgqE+fQ2UJSzv0gC+hNleIpToiLsYWa+",
	"s/94WMDXjAoI8VSJDDwsgwgSoufAPUnSWA+NeUDikVRckCVMUyIU1cKnCy4SorCH1TrV46QSlC3xZuM5",
	"6uU+srxtPyc8Y1qTWcjXDMS6vhKJXdOpgsTobRhWWkqEIGtj6K8rYOop3BRSeTslYQhhp4NKvbKfEK/j",
	"BwEJXxn5g7tlxjMRwMX5Fq9I8/MNDQ9xTYc/NlYMSHXGQ2p98j7zYyoj4yj9OeBM5f8laRrTgGhkTL5I",
	"zvR3lVoShgY0JH4veApC5QJbqw5BBoKmeiyeYtCKUFpN8aoFfG/EJeEhxHiKfxHZNxDYa/ycZTTEU3x6",
	"egLH8IM/+il8A6PTBfw48k//tRj9FJy+Pn29CCEI/92auwIWcoGneEbYOZW3Tni4/wUCZd1Vt/3o4+X5",
	"5atWMDYe/gBLKhUIm5Af16n1RW9nlpj5fwELPMX/N6mqzsQOk5NKeAeYDjDWxPyJbC1lP87Uj4Iul4Vb",
	"nwOexGjqic99APgYfJm8lSln0q7hHagKC5d/7OWXvgBrW3f5h15ETbfcU/kTwLy0qkTcgA5xUNxH85O4",
	"Y69Msja5NX1ob2zX+iGH6BkJP9gu00Ozk1sJSKn71hSfkRAVIjZeT+vOiITChC4jG0KLob9wtohpcLCt",
	"5fzBDHUlFuMumALBSDwDsQLxqxC6dw0U1l325FXJseYvrn7jGQsP9dlfXCErYDCn1UQWAwfE/i79NgVq",
	"7WrwwrxNb+lEZ0titiq1xsdy9t3Z73L+/SBB3rYP8RqK/vbE0MuJueXtDX9KyQNKFITIDkKGvffm6B5W",
	"NAGpSJK2hZc/IRVRifLYKc5vURqTQIvLgzTFIVEw0hM690UVwfhcLcYrtmFOEK47Vu806P1RdsWu2JGK",
	"QACiEjGuv6RsiQLONAD0sAUXyJkhPeRnClGlJwgIeJIACyFEykwGBCSIEJFIKpEFKhMkRoSFqDRhBfrX",
	"lEtJ/RhePRrna730/1Db33r18PfOxHYbfxBP1g8llvSiaagdtVijO+NGFUHhrjsax0iRW9gHcn3hUC27",
	"CxS1AtmCRVn7m+vLf0ACVCYYhMhfI2maHJI0BEQXqAQLYevaugxRJuEli9fFrrhjx1vubPsA1RahPtVw",
	"y5nDP8XwhYqh9djetdDD1j/dQDC/uQb39OLABbfaAuwN457ltprw3NV2Vx49Z7G1XthVa+2ogCcg0ULw",
	"5PlrbW2FLUjU1uQeD/5ORHhHBCCb1ogvbOo8kH9O0ankFMWgY3w3HItFlYi8yo6P3wC6aIHMtH5UG6+j",
	"4BtMbYHYGF0yQNwo0/IUR6mABb1Hd1RFiFhYpySAcal5hC5MY6lUaT/YwMsUArqggVcTk/94cT5Gv+mE",
	"sd7w0LyrYs4dRZc6++6ohLq8uV40Z9N5U17+PSSExqWcUt6MJ4B8EhYTJNIBndNw7qE5Wek5Hpr78e18",
	"PB7fRTSIUECYcWDi02XGM2nSNeBskUnKluMHEjQv/7tQbILexqlONQgyQdV6plMzb4hBAFLeKH4LrDz2",
	"joCEpnXlB99vMxVxQb+ZvVKln6T0D8jPPShb8DbSjJeClOrCBIXrEELI/pAHMYGQkp+v8JEOCAg5CnjM",
	"xcgUEJiikIjbV1cYSRFIUD9f4UipVE4nE0HuxkuqoszPJIh8ZzcOeDK5COBTRGL4CEE0ifmSTxJC2SQg",
	"knCZ/3PjE8ZA3GjxN4wuI3Xz4/Fxej9O2fIKH2psrAU9obXqjhoVN36cwcMG02SJSKxN+IVIcjmzRj2/",
	"RdaaSQMFV8xahf7MKeeZToUggFTl7MFmhqXStrSjFRFUp4yNhcw7XUxXIKSuH4muNjLzNQZ9EFJXGKbz",
	"mUqZFeOpDDIptVAPpTEQCWhFJVWmAH1+R9XvmY8EpFxSxcX6+qjwl/VV20F2Ia8QF+gLpwx95plA51QG",
	"XITV7NB+MV4uJ7fs61vfP/Phv6/GVyahqDL53uGSt+8vsIf1Am1KrU50YecpMJJSPMVvxsfjN7pTERWZ",
	"jJ5Yj02+l9dVG/31ElQ7P2eFq7TfCk/7azQv587RihL0CfwZD25BjZ12MTeFfF4UtLxOQ4goM640N3PI",
	"FqlaXMyHvKqXu+Z1CtI6Q3cAU2kuQtdEu839NDNrrS59P3ezj2rIpLzV23g7x7o3uJvrxjn/6+PXbRd+",
	"jEBXbwbOls8HlKVLQXKe5vjPHarBqP0UxFQzGDNTQACmn+axIAbWa9NVlD3NglC7yZTzLEmIWD8Qx7JL",
	"oqPSBE0BFVlq1+HKrl9ZmHLKlMTXWnQHiCbfdbwNllIuO8CUn7YhwoqgcguEYlPpZ50Rrl8qPU908+AW",
	"l6/rbSS2dj87qVvavAY6OT7eLiYfN2keSW48fNpnXsdpvpl62n9qeUxcx04rbA4+rJkoARXxsA6NG5Wz",
	"3c7CorkyInFcS2+kIqIMlINMCGAqXiORX35CaHlYD7zUr7zwIVFo3ZrVXWKtdyxvuUTPc9zibUmJ4moX",
	"cU2JBUq4AMTgru6WvgvvutU+AMVdYg7CsnOu/1gY/9R/anUfU4tZp6v3iWED2r365zt4COU7sJ3vrspO",
	"WG1pdoL+bD2rtqqH1svrYTJnmCpkPOl60e1ejwid07W2R5C5qm38zEb4sPA5tNXsdXeG83l73qMiPnDA",
	"646vERbtxPwQZmfszXZhf8JrT46el+7m56I72a45Y3xisuu8xntJrlts9hyqm9oXEzupbj71UUy3BZ6d",
	"RDd/z6HhWxxz92nftad9zxLXw1huzc6DiEHjwcvLc9xmxBxgGCO76klPgusk9HD81nkKeGDJrj2C2nj4",
	"h30C0PW8pYMhO0tvOvSx/Nj16r70uOG8A9mxI+VvSo77h6+eE3sx4870GJgYV6F6UV7cTLmhWJLrwi2s",
	"eL+g9eTEld5hKHF1qbkrjs/aHR8T6cHpsOPzXWx4W8ylZa6U70GC60ftmgJbsnRxaRjwqPyI5oLzZI5k",
	"xLM41OQPqIpAoLmRM9fFZW7lzB+it7OLSzwY4yyNG4pwegUSGryPx7Em95RRRUlMv+U3pIX+XlzVdfRR",
	"MdNlquVqXKK6rYFqk7ok++tmFNt0lMdxRxgeXHnAmaIs0+sWPNm+8G1m9V9wDcmTrVAurmFJYu6g59Wc",
	"OYL7AFLzdMI+Dsivn5Ug1CxGxkRGaD6ZoxEi6I6LWyJ0ZupgJeSeJvSbBl+SEkV9GlO13oHok38g7UZ4",
	"K2hfPGg59E9eCvsb9zLe9Lf6Nfzna92a7Ls72/8yEeMpnqxOJnm7vfEzu2vPs6j9kM/0BBPMhDCy1Etw",
	"mISnPX8HcWyeblio6CHa4uLkIj/IsGupXgPUd0y64/ZQ7Z7t7aE7d57zFKF+I9HWXhQRZC5EjRGd62l1",
	"vPKEoFL2CXzZPDQYUGMBiEphRyls67P36eYNBzmHhUldzpB9b/UBFj9f7fjLlSuMJjYHG0HNn2gNqnCr",
	"sgEVVQeDXdpqf8A0rMrt6gZU5T4v61JYf2B37eH7kSLLd4Jnqa0M+bg/85x5iEJ6jez2ug5dvfa9oFdq",
	"qZD78OGbt4XolIJm+d9QdJhbmFkzr/yAGy/yrjfXm/8FAAD//yaxUhg3PgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
